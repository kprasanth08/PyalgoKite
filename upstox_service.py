import upstox_client
from upstox_client.api import LoginApi, MarketQuoteApi, MarketQuoteV3Api, HistoryV3Api, WebsocketApi  # Added WebsocketApi
from upstox_client.rest import ApiException
from upstox_client.configuration import Configuration

import json
import logging
import os
import time
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Add CSV handling imports
import csv
import requests
import gzip  # Add gzip module for handling compressed files
from io import StringIO, BytesIO  # Add BytesIO for binary data handling
import pandas as pd

# Configure logger first
logger = logging.getLogger(__name__)

# For WebSocket client
import asyncio
import websockets

# Attempt to import the generated Protobuf file
# This file should be generated by you using protoc (see instructions)
# Use a global variable to track if we've already loaded the proto descriptor
_PROTOBUF_LOADED = False

try:
    # Only try to load the protobuf descriptors once
    if not _PROTOBUF_LOADED:
        import MarketDataFeed_pb2  # Assumes MarketDataFeed_pb2.py is in the same directory or Python path
        _PROTOBUF_LOADED = True
    else:
        import importlib
        MarketDataFeed_pb2 = importlib.import_module('MarketDataFeed_pb2')
except ImportError:
    logger.error("MarketDataFeed_pb2.py not found. Please generate it from the .proto file.")
    MarketDataFeed_pb2 = None

load_dotenv()

# Upstox API Configuration
UPSTOX_API_KEY = os.getenv('UPSTOX_API_KEY')
UPSTOX_API_SECRET = os.getenv('UPSTOX_API_SECRET')
UPSTOX_REDIRECT_URI = os.getenv('UPSTOX_REDIRECT_URI', 'http://localhost:6010/upstox_callback')

# NSE CSV file URLs and local storage paths
NSE_CSV_URL = "https://assets.upstox.com/market-quote/instruments/exchange/NSE.csv.gz"
NSE_CSV_LOCAL_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "instrument_cache", "nse_instruments.csv")
NSE_CSV_PROCESSED_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "instrument_cache", "nse_instruments_processed.json")

# Global token storage
_access_token = None
_token_expiry = None

# Global cache for instruments
_instruments_cache = {
    "NSE_EQ": None,
    "BSE_EQ": None,
    "NSE_FO": None,
    "last_updated": None
}

def get_access_token():
    """
    Get or refresh access token for Upstox API V3

    Note: Upstox requires OAuth authorization flow with user interaction.
    This function should be used after obtaining an authorization code through the redirect callback.
    """
    global _access_token, _token_expiry

    # If token exists and not expired, return it
    if _access_token and _token_expiry and datetime.now() < _token_expiry:
        return _access_token

    # Try to read token from a file - which should be populated by the redirect callback
    token_file = os.path.join(os.getcwd(), 'upstox_token.json')

    if os.path.exists(token_file):
        try:
            with open(token_file, 'r') as f:
                stored_data = json.load(f)

            # Check if token is still valid
            if stored_data.get('expires_at') and datetime.fromisoformat(stored_data['expires_at']) > datetime.now():
                _access_token = stored_data['access_token']
                _token_expiry = datetime.fromisoformat(stored_data['expires_at'])
                logger.info(f"Loaded valid Upstox access token from file, expires at {_token_expiry}")
                return _access_token
            else:
                logger.warning("Stored Upstox token has expired")
        except Exception as e:
            logger.error(f"Error reading Upstox token file: {e}")

    # If we get here, we need a new token, but this requires user interaction
    logger.error("Upstox authentication requires user interaction. Please use the login flow.")
    return None

def save_access_token(access_token, expires_in=86400):
    """
    Save access token to file for persistence

    Args:
        access_token (str): The access token to save
        expires_in (int): Expiry time in seconds from now
    """
    global _access_token, _token_expiry

    _access_token = access_token
    _token_expiry = datetime.now() + timedelta(seconds=expires_in - 300)  # 5 minutes buffer

    token_file = os.path.join(os.getcwd(), 'upstox_token.json')

    try:
        with open(token_file, 'w') as f:
            json.dump({
                'access_token': access_token,
                'expires_at': _token_expiry.isoformat()
            }, f)
        logger.info(f"Saved Upstox access token to file, expires at {_token_expiry}")
    except Exception as e:
        logger.error(f"Error saving Upstox token to file: {e}")

def get_auth_token_from_code(auth_code):
    """
    Exchange authorization code for access token

    Args:
        auth_code (str): The authorization code from OAuth callback

    Returns:
        str: The access token or None if failed
    """
    if not UPSTOX_API_KEY or not UPSTOX_API_SECRET or not UPSTOX_REDIRECT_URI:
        logger.error("Upstox API key, secret or redirect URI not configured")
        return None

    try:
        import requests
        token_url = "https://api.upstox.com/v2/login/authorization/token"

        # Prepare the data for token request
        data = {
            'code': auth_code,
            'client_id': UPSTOX_API_KEY,
            'client_secret': UPSTOX_API_SECRET,
            'redirect_uri': UPSTOX_REDIRECT_URI,
            'grant_type': 'authorization_code'
        }

        # Make the request to get the access token
        response = requests.post(token_url, data=data)
        if response.status_code == 200:
            token_data = response.json()
            if 'access_token' in token_data:
                # Save the token for future use
                save_access_token(token_data['access_token'], int(token_data.get('expires_in', 86400)))
                logger.info("Upstox API V3: Access token obtained successfully from auth code")
                return token_data['access_token']
            else:
                logger.error(f"Upstox API V3: Invalid response format: {token_data}")
                return None
        else:
            logger.error(f"Upstox API V3: Failed to get access token from auth code, status code: {response.status_code}, response: {response.text}")
            return None
    except Exception as e:
        logger.error(f"Error getting Upstox access token from auth code: {e}")
        return None

def get_configuration():
    """
    Create and return an Upstox API configuration object
    """
    token = get_access_token()
    if not token:
        return None

    configuration = Configuration()
    configuration.access_token = token
    return configuration

def get_configuration_api_client():
    """
    Create and return an Upstox API client instance.
    """
    token = get_access_token()
    if not token:
        logger.error("Access token not available for Upstox API configuration.")
        return None

    config_obj = Configuration()
    config_obj.access_token = token
    api_client = upstox_client.ApiClient(configuration=config_obj)
    return api_client

def get_market_quote_api():
    """
    Get an instance of the MarketQuoteApi
    """
    config = get_configuration()
    if not config:
        return None
    return MarketQuoteApi(configuration=config)

def get_market_quote_v3_api():
    """
    Get an instance of the MarketQuoteV3Api
    """
    config = get_configuration()
    if not config:
        return None
    return MarketQuoteV3Api(configuration=config)

def get_history_v3_api():
    """
    Get an instance of the HistoryV3Api
    """
    config = get_configuration()
    if not config:
        return None
    return HistoryV3Api(configuration=config)

def get_login_api():
    """
    Get an instance of the LoginApi for authentication flow
    """
    config = Configuration()  # No token needed for login
    if not config:
        return None
    return LoginApi(configuration=config)

def get_upstox_login_url():
    """
    Generate a login URL for Upstox authentication
    """
    try:
        login_api = get_login_api()
        response = login_api.login(
            api_version="3.0",
            redirect_uri=UPSTOX_REDIRECT_URI,
            api_key=UPSTOX_API_KEY,
            response_type="code",
            client_id=UPSTOX_API_KEY,
            scope="",
            state=""
        )
        return response.login_url
    except ApiException as e:
        logger.error(f"Exception when calling LoginApi->login: {e}")
        return None
    except Exception as e:
        logger.error(f"Error generating Upstox login URL: {str(e)}")
        return None

def get_market_data_feed_authorize_url(api_client_instance):
    """
    Gets the market data feed authorize URL using an ApiClient instance.
    """
    if not api_client_instance:
        logger.error("ApiClient instance is required for get_market_data_feed_authorize_url")
        return None
    try:
        ws_api = WebsocketApi(api_client_instance)
        response = ws_api.get_market_data_feed_authorize(api_version="3.0")  # Corrected api_version to "3.0"
        logger.info("Market data feed authorize URL obtained successfully.")
        return response.data.authorized_redirect_uri
    except ApiException as e:
        logger.error(f"ApiException when calling WebsocketApi->get_market_data_feed_authorize: {e}")
        if e.body:
            logger.error(f"Error body: {e.body}")
        return None
    except Exception as e:
        logger.error(f"Error getting market data feed authorize URL: {e}")
        return None

async def connect_and_stream_market_data(feed_url, instrument_keys, on_message_callback):
    """
    Connects to the Upstox market data WebSocket and streams data.
    """
    if not MarketDataFeed_pb2:
        logger.error("MarketDataFeed_pb2 module not loaded. Cannot stream market data.")
        return

    try:
        async with websockets.connect(feed_url, ping_interval=30, ping_timeout=10) as websocket:
            logger.info(f"Successfully connected to Upstox Market Data WebSocket: {feed_url}")

            sub_request = {
                "guid": "pyalgo-guid-" + str(time.time()),
                "method": "sub",
                "data": {
                    "instrumentKeys": instrument_keys
                }
            }
            await websocket.send(json.dumps(sub_request))
            logger.info(f"Sent subscription request for instruments: {instrument_keys}")

            while True:
                message = await websocket.recv()
                feed_response = MarketDataFeed_pb2.FeedResponse()
                feed_response.ParseFromString(message)

                if on_message_callback:
                    on_message_callback(feed_response)

    except websockets.exceptions.ConnectionClosed as e:
        logger.error(f"WebSocket connection closed: {e}")
    except websockets.exceptions.InvalidStatusCode as e:
        logger.error(f"WebSocket connection failed with status code: {e.status_code} - {e.headers}")
    except Exception as e:
        logger.error(f"Error in WebSocket connection/streaming: {e}", exc_info=True)
    finally:
        logger.info("WebSocket connection closed or an error occurred.")

def get_live_market_data(symbol, exchange="NSE_EQ"):
    """
    Get live market data for a symbol from Upstox using V3 HTTP API.
    This is used for initial data loading, while WebSockets handle continuous updates.

    Args:
        symbol (str): Symbol/scrip code
        exchange (str): Exchange code, default is NSE_EQ (NSE Equity)
    Returns:
        dict: Market data or None if an error occurs.
    """
    market_quote_api = get_market_quote_v3_api()
    if not market_quote_api:
        logger.error("Failed to create MarketQuoteV3Api instance for get_live_market_data")
        return None

    try:
        instrument_key = f"{exchange}:{symbol}"
        # Using get_full_market_quote to get comprehensive data including LTP, change, OHLC etc.
        # The API version "3.0" should be handled by the underlying SDK method.
        # The SDK method is get_full_market_quote(symbol, api_version)
        # However, the Upstox SDK might implicitly use the correct version or require it in ApiClient config.
        # Let's assume the SDK handles the version or it's set globally.

        # The method signature for get_full_market_quote in the SDK is typically:
        # get_full_market_quote(self, symbol, api_version, **kwargs)
        # We need to ensure the api_version is correctly passed or configured.
        # For safety, let's try to pass it if the method accepts it,
        # otherwise rely on global config or SDK default.

        # The Upstox client library's MarketQuoteV3Api().get_full_market_quote takes 'symbol' and 'api_version'.
        response = market_quote_api.get_full_market_quote(
            symbol=instrument_key,
            api_version="3.0" # Explicitly pass api_version
        )

        if response and response.data:
            # The structure of response.data needs to be mapped to what the frontend expects.
            # Assuming response.data is an object with fields like last_price, change, ohlc etc.
            # Example mapping (adjust based on actual response structure from Upstox SDK):
            data = response.data
            # The V3 full market quote response is nested. Example: data.market_data.ltpc
            ltpc_data = data.get(instrument_key, {}).get('market_data', {}).get('ltpc', {})
            ohlc_data = data.get(instrument_key, {}).get('market_data', {}).get('ohlc', {})

            live_data = {
                "ltp": ltpc_data.get('ltp'),
                "change": ltpc_data.get('ch'), # Or calculate if 'ch' is not direct change value
                "percentage_change": ltpc_data.get('chp'),
                "open": ohlc_data.get('open'),
                "high": ohlc_data.get('high'),
                "low": ohlc_data.get('low'),
                "close": ohlc_data.get('close'), # Previous day close for ohlc
                "symbol": symbol,
                "instrument_key": instrument_key
                # Add other fields as needed by your frontend
            }
            return live_data
        else:
            logger.warning(f"No data received from get_full_market_quote for {instrument_key}")
            return None

    except ApiException as e:
        logger.error(f"ApiException when calling MarketQuoteV3Api->get_full_market_quote for {symbol}: {e}")
        if e.body:
            logger.error(f"Error body: {e.body}")
        return None
    except Exception as e:
        logger.error(f"Error fetching live market data for {symbol} via HTTP: {e}", exc_info=True)
        return None


def get_historical_data(symbol, interval="1day", from_date=None, to_date=None, exchange="NSE_EQ"):
    """
    Get historical OHLC data for a symbol from Upstox using V3 API

    Args:
        symbol (str): Symbol/scrip code
        interval (str): Candle interval (V3 API format: 1minute, 1day, 1week, 1month)
        from_date (str): Start date in YYYY-MM-DD format
        to_date (str): End date in YYYY-MM-DD format
        exchange (str): Exchange code, default is NSE_EQ
    """
    history_api = get_history_v3_api()
    if not history_api:
        logger.error("Failed to create HistoryV3Api instance")
        return None

    # Map the interval format from old API to new V3 API if needed
    interval_mapping = {
        "minute": "1minute",
        "day": "1day",
        "week": "1week",
        "month": "1month"
    }

    # Use the mapping if an old-style interval is provided
    if interval in interval_mapping:
        interval = interval_mapping[interval]

    try:
        # Format instrument key for Upstox API V3
        instrument_key = f"{exchange}:{symbol}"

        # Default to last 30 days if no dates provided
        if not from_date or not to_date:
            to_date = datetime.now().strftime("%Y-%m-%d")
            from_date = (datetime.now() - timedelta(days=30)).strftime("%Y-%m-%d")

        # Get historical data
        response = history_api.get_candle_data(
            symbol=instrument_key,
            interval=interval,
            from_date=from_date,
            to_date=to_date,
            api_version="3.0"
        )

        return response.data.candles if response and response.data else None
    except ApiException as e:
        logger.error(f"Exception when calling HistoryV3Api->get_candle_data: {e}")
        return None
    except Exception as e:
        logger.error(f"Error fetching historical data from Upstox for {symbol}: {e}")
        return None
def get_auth_code_from_url(redirect_url):
    """
    Extract the authorization code from the redirect URL
    For use with the redirect callback
    """
    try:
        import urllib.parse
        parsed_url = urllib.parse.urlparse(redirect_url)
        query_params = urllib.parse.parse_qs(parsed_url.query)

        if 'code' in query_params:
            return query_params['code'][0]
        return None
    except Exception as e:
        logger.error(f"Error extracting auth code from URL: {str(e)}")
        return None

def get_instruments_cache(exchange="NSE_EQ"):
    """
    Get instruments cache for the specified exchange.
    Loads from processed JSON file if available.

    Args:
        exchange (str): Exchange code, default is NSE_EQ (NSE Equity)

    Returns:
        list: List of instruments for the specified exchange
    """
    global _instruments_cache

    # Check if cache is already loaded
    if _instruments_cache.get(exchange) is not None:
        return _instruments_cache[exchange]

    # Load from processed JSON file
    try:
        if exchange == "NSE_EQ":
            cache_file = NSE_CSV_PROCESSED_PATH
        else:
            # Currently only supporting NSE_EQ
            logger.warning(f"Instruments cache not implemented for exchange: {exchange}")
            return []

        if os.path.exists(cache_file):
            with open(cache_file, 'r') as f:
                instruments = json.load(f)

            # Store in memory cache
            _instruments_cache[exchange] = instruments
            _instruments_cache["last_updated"] = datetime.now().isoformat()

            logger.info(f"Loaded {len(instruments)} instruments for {exchange} from cache")
            return instruments
        else:
            logger.warning(f"Instruments cache file not found: {cache_file}")
            return []
    except Exception as e:
        logger.error(f"Error loading instruments cache for {exchange}: {str(e)}")
        return []

def search_instruments(query, exchange="NSE_EQ"):
    """
    Search for instruments based on a query string using Upstox OHLC V3 API

    Args:
        query (str): Search query string (symbol or name)
        exchange (str): Exchange code, default is NSE_EQ (NSE Equity)

    Returns:
        list: List of matching instruments
    """
    try:
        # Get the access token for authorization
        token = get_access_token()
        if not token:
            logger.error("Failed to get access token for instrument search")
            return []

        # Get processed instruments cache
        instruments = get_instruments_cache(exchange)
        if not instruments:
            logger.error(f"No instruments available for exchange {exchange}")
            return []

        # Perform a case-insensitive search on both symbol and name
        query = query.upper()
        results = []

        for inst in instruments:
            # Check if the query matches the symbol or name
            symbol = inst.get('symbol', '').upper()
            name = inst.get('name', '').upper()

            if query in symbol or query in name:
                results.append(inst)

                # Limit results to a reasonable number
                if len(results) >= 20:
                    break

        return results
    except Exception as e:
        logger.error(f"Error searching instruments: {str(e)}")
        return []
def search_symbols(api_client, query, exchange="NSE_EQ"):
    """
    Search for symbols using the API client

    Args:
        api_client: Configured Upstox API client
        query (str): Search query string (symbol or name)
        exchange (str): Exchange code, default is NSE_EQ (NSE Equity)

    Returns:
        list: List of matching symbols with formatted data for frontend
    """
    try:
        # First try to search using existing instruments cache
        results = search_instruments(query, exchange)

        # Format the results for frontend display
        formatted_results = []

        for inst in results:
            symbol = inst.get('symbol', '')
            name = inst.get('name', '')
            instrument_key = inst.get('instrument_key', '')
            isin = inst.get('isin', '')

            if symbol and instrument_key:
                formatted_results.append({
                    "symbol": symbol,
                    "name": name,
                    "instrument_key": instrument_key,
                    "isin": isin,
                    "exchange": exchange
                })

        return formatted_results
    except Exception as e:
        logger.error(f"Error in search_symbols: {str(e)}")
        return []
