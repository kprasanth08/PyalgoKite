import upstox_client
from upstox_client.api import LoginApi, MarketQuoteApi, MarketQuoteV3Api, HistoryV3Api, WebsocketApi  # Added WebsocketApi
from upstox_client.rest import ApiException
from upstox_client.configuration import Configuration

import json
import logging
import os
import time
from datetime import datetime, timedelta
from dotenv import load_dotenv

# Add CSV handling imports
import csv
import requests
import gzip  # Add gzip module for handling compressed files
from io import StringIO, BytesIO  # Add BytesIO for binary data handling
import pandas as pd

# Configure logger first
logger = logging.getLogger(__name__)

# For WebSocket client
import asyncio
import websockets

# Attempt to import the generated Protobuf file
# This file should be generated by you using protoc (see instructions)
# Use a global variable to track if we've already loaded the proto descriptor
_PROTOBUF_LOADED = False

try:
    # Only try to load the protobuf descriptors once
    if not _PROTOBUF_LOADED:
        import MarketDataFeed_pb2  # Assumes MarketDataFeed_pb2.py is in the same directory or Python path
        _PROTOBUF_LOADED = True
    else:
        import importlib
        MarketDataFeed_pb2 = importlib.import_module('MarketDataFeed_pb2')
except ImportError:
    logger.error("MarketDataFeed_pb2.py not found. Please generate it from the .proto file.")
    MarketDataFeed_pb2 = None

load_dotenv()

# Upstox API Configuration
UPSTOX_API_KEY = os.getenv('UPSTOX_API_KEY')
UPSTOX_API_SECRET = os.getenv('UPSTOX_API_SECRET')
UPSTOX_REDIRECT_URI = os.getenv('UPSTOX_REDIRECT_URI', 'http://localhost:6010/upstox_callback')

# NSE CSV file URLs and local storage paths
NSE_CSV_URL = "https://assets.upstox.com/market-quote/instruments/exchange/NSE.csv.gz"
NSE_CSV_LOCAL_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "instrument_cache", "nse_instruments.csv")
NSE_CSV_PROCESSED_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "instrument_cache", "nse_instruments_processed.json")

# Global token storage
_access_token = None
_token_expiry = None

# Global cache for instruments
_instruments_cache = {
    "NSE_EQ": None,
    "BSE_EQ": None,
    "NSE_FO": None,
    "last_updated": None
}

def refresh_and_filter_nse_instruments():
    """
    Downloads, filters (for NSE_EQ), and saves NSE instruments to the cache file.
    Updates the in-memory cache as well.
    """
    try:
        logger.info(f"Attempting to download instruments from {NSE_CSV_URL}")
        response = requests.get(NSE_CSV_URL, stream=True)
        response.raise_for_status() # Raises an HTTPError for bad responses (4XX or 5XX)

        logger.info("Decompressing and reading CSV data...")
        # Use BytesIO to handle the binary content in memory for gzip
        with gzip.GzipFile(fileobj=BytesIO(response.content)) as gz_file:
            # Read the decompressed content as text (assuming UTF-8 encoding)
            csv_content = gz_file.read().decode('utf-8')
            # Use StringIO to treat the string as a file for csv.DictReader
            csv_file = StringIO(csv_content)
            reader = csv.DictReader(csv_file)
            all_instruments = list(reader)

        logger.info(f"Downloaded {len(all_instruments)} instruments. Filtering for exchange='NSE_EQ'...")

        nse_eq_instruments = []
        for instrument in all_instruments:
            # Assuming the CSV has an 'exchange' column and its value can be 'NSE_EQ'.
            # Adjust this condition if the CSV structure is different
            # (e.g., if exchange is 'NSE' and another column like 'instrument_type' is 'EQ').
            if instrument.get('exchange') == 'NSE_EQ':
                nse_eq_instruments.append(instrument)

        logger.info(f"Found {len(nse_eq_instruments)} NSE_EQ instruments after filtering.")

        # Ensure the cache directory exists
        cache_dir = os.path.dirname(NSE_CSV_PROCESSED_PATH)
        if not os.path.exists(cache_dir):
            os.makedirs(cache_dir)
            logger.info(f"Created cache directory: {cache_dir}")

        with open(NSE_CSV_PROCESSED_PATH, 'w') as f:
            json.dump(nse_eq_instruments, f, indent=4)

        logger.info(f"Successfully saved {len(nse_eq_instruments)} NSE_EQ instruments to {NSE_CSV_PROCESSED_PATH}")

        # Update in-memory cache
        global _instruments_cache
        _instruments_cache["NSE_EQ"] = nse_eq_instruments
        _instruments_cache["last_updated"] = datetime.now().isoformat()
        return True

    except requests.exceptions.RequestException as e:
        logger.error(f"Error downloading instruments from {NSE_CSV_URL}: {e}")
    except gzip.BadGzipFile:
        logger.error(f"Failed to decompress the downloaded file from {NSE_CSV_URL}. It might not be a valid Gzip file.")
    except csv.Error as e:
        logger.error(f"Error reading or parsing CSV data: {e}")
    except IOError as e:
        logger.error(f"Error writing processed instruments to {NSE_CSV_PROCESSED_PATH}: {e}")
    except Exception as e:
        logger.error(f"An unexpected error occurred during instrument processing: {e}", exc_info=True)
    return False

def get_access_token():
    """
    Get or refresh access token for Upstox API V3

    Note: Upstox requires OAuth authorization flow with user interaction.
    This function should be used after obtaining an authorization code through the redirect callback.
    """
    global _access_token, _token_expiry

    # If token exists and not expired, return it
    if _access_token and _token_expiry and datetime.now() < _token_expiry:
        return _access_token

    # Try to read token from a file - which should be populated by the redirect callback
    token_file = os.path.join(os.getcwd(), 'upstox_token.json')

    if os.path.exists(token_file):
        try:
            with open(token_file, 'r') as f:
                stored_data = json.load(f)

            # Check if token is still valid
            if stored_data.get('expires_at') and datetime.fromisoformat(stored_data['expires_at']) > datetime.now():
                _access_token = stored_data['access_token']
                _token_expiry = datetime.fromisoformat(stored_data['expires_at'])
                logger.info(f"Loaded valid Upstox access token from file, expires at {_token_expiry}")
                return _access_token
            else:
                logger.warning("Stored Upstox token has expired")
        except Exception as e:
            logger.error(f"Error reading Upstox token file: {e}")

    # If we get here, we need a new token, but this requires user interaction
    logger.error("Upstox authentication requires user interaction. Please use the login flow.")
    return None

def save_access_token(access_token, expires_in=86400):
    """
    Save access token to file for persistence

    Args:
        access_token (str): The access token to save
        expires_in (int): Expiry time in seconds from now
    """
    global _access_token, _token_expiry

    _access_token = access_token
    _token_expiry = datetime.now() + timedelta(seconds=expires_in - 300)  # 5 minutes buffer

    token_file = os.path.join(os.getcwd(), 'upstox_token.json')

    try:
        with open(token_file, 'w') as f:
            json.dump({
                'access_token': access_token,
                'expires_at': _token_expiry.isoformat()
            }, f)
        logger.info(f"Saved Upstox access token to file, expires at {_token_expiry}")
    except Exception as e:
        logger.error(f"Error saving Upstox token to file: {e}")

def get_auth_token_from_code(auth_code):
    """
    Exchange authorization code for access token

    Args:
        auth_code (str): The authorization code from OAuth callback

    Returns:
        str: The access token or None if failed
    """
    if not UPSTOX_API_KEY or not UPSTOX_API_SECRET or not UPSTOX_REDIRECT_URI:
        logger.error("Upstox API key, secret or redirect URI not configured")
        return None

    try:
        import requests
        token_url = "https://api.upstox.com/v2/login/authorization/token"

        # Prepare the data for token request
        data = {
            'code': auth_code,
            'client_id': UPSTOX_API_KEY,
            'client_secret': UPSTOX_API_SECRET,
            'redirect_uri': UPSTOX_REDIRECT_URI,
            'grant_type': 'authorization_code'
        }

        # Make the request to get the access token
        response = requests.post(token_url, data=data)
        if response.status_code == 200:
            token_data = response.json()
            if 'access_token' in token_data:
                # Save the token for future use
                save_access_token(token_data['access_token'], int(token_data.get('expires_in', 86400)))
                logger.info("Upstox API V3: Access token obtained successfully from auth code")
                return token_data['access_token']
            else:
                logger.error(f"Upstox API V3: Invalid response format: {token_data}")
                return None
        else:
            logger.error(f"Upstox API V3: Failed to get access token from auth code, status code: {response.status_code}, response: {response.text}")
            return None
    except Exception as e:
        logger.error(f"Error getting Upstox access token from auth code: {e}")
        return None

def get_configuration():
    """
    Create and return an Upstox API configuration object
    """
    token = get_access_token()
    if not token:
        return None

    configuration = Configuration()
    configuration.access_token = token
    return configuration

def get_configuration_api_client():
    """
    Create and return an Upstox API client instance.
    """
    token = get_access_token()
    if not token:
        logger.error("Access token not available for Upstox API configuration.")
        return None

    config_obj = Configuration()
    config_obj.access_token = token
    api_client = upstox_client.ApiClient(configuration=config_obj)
    return api_client

def get_market_quote_api():
    """
    Get an instance of the MarketQuoteApi
    """
    config = get_configuration()
    if not config:
        return None
    return MarketQuoteApi(configuration=config)

def get_market_quote_v3_api():
    """
    Get an instance of the MarketQuoteV3Api
    """
    config = get_configuration()
    if not config:
        return None
    return MarketQuoteV3Api(configuration=config)

def get_history_v3_api():
    """
    Get an instance of the HistoryV3Api
    """
    config = get_configuration()
    if not config:
        return None
    return HistoryV3Api(configuration=config)

def get_login_api():
    """
    Get an instance of the LoginApi for authentication flow
    """
    config = Configuration()  # No token needed for login
    if not config:
        return None
    return LoginApi(configuration=config)

def get_upstox_login_url():
    """
    Generate a login URL for Upstox authentication
    """
    try:
        login_api = get_login_api()
        response = login_api.login(
            api_version="3.0",
            redirect_uri=UPSTOX_REDIRECT_URI,
            api_key=UPSTOX_API_KEY,
            response_type="code",
            client_id=UPSTOX_API_KEY,
            scope="",
            state=""
        )
        return response.login_url
    except ApiException as e:
        logger.error(f"Exception when calling LoginApi->login: {e}")
        return None
    except Exception as e:
        logger.error(f"Error generating Upstox login URL: {str(e)}")
        return None

def get_market_data_feed_authorize_url(api_client_instance):
    """
    Gets the market data feed authorize URL using an ApiClient instance.
    """
    if not api_client_instance:
        logger.error("ApiClient instance is required for get_market_data_feed_authorize_url")
        return None
    try:
        ws_api = WebsocketApi(api_client_instance)
        response = ws_api.get_market_data_feed_authorize(api_version="3.0")  # Corrected api_version to "3.0"
        logger.info("Market data feed authorize URL obtained successfully.")
        return response.data.authorized_redirect_uri
    except ApiException as e:
        logger.error(f"ApiException when calling WebsocketApi->get_market_data_feed_authorize: {e}")
        if e.body:
            logger.error(f"Error body: {e.body}")
        return None
    except Exception as e:
        logger.error(f"Error getting market data feed authorize URL: {e}")
        return None

async def connect_and_stream_market_data(feed_url, instrument_keys, on_message_callback):
    """
    Connects to the Upstox market data WebSocket and streams data.
    """
    if not MarketDataFeed_pb2:
        logger.error("MarketDataFeed_pb2 module not loaded. Cannot stream market data.")
        return

    try:
        async with websockets.connect(feed_url, ping_interval=30, ping_timeout=10) as websocket:
            logger.info(f"Successfully connected to Upstox Market Data WebSocket: {feed_url}")

            sub_request = {
                "guid": "pyalgo-guid-" + str(time.time()),
                "method": "sub",
                "data": {
                    "instrumentKeys": instrument_keys
                }
            }
            await websocket.send(json.dumps(sub_request))
            logger.info(f"Sent subscription request for instruments: {instrument_keys}")

            while True:
                message = await websocket.recv()
                feed_response = MarketDataFeed_pb2.FeedResponse()
                feed_response.ParseFromString(message)

                if on_message_callback:
                    on_message_callback(feed_response)

    except websockets.exceptions.ConnectionClosed as e:
        logger.error(f"WebSocket connection closed: {e}")
    except websockets.exceptions.InvalidStatusCode as e:
        logger.error(f"WebSocket connection failed with status code: {e.status_code} - {e.headers}")
    except Exception as e:
        logger.error(f"Error in WebSocket connection/streaming: {e}", exc_info=True)
    finally:
        logger.info("WebSocket connection closed or an error occurred.")

def get_live_market_data(symbol, exchange="NSE_EQ"):
    """
    Get live market data for a symbol from Upstox using V3 HTTP API.
    This is used for initial data loading, while WebSockets handle continuous updates.

    Args:
        symbol (str): Symbol/scrip code
        exchange (str): Exchange code, default is NSE_EQ (NSE Equity)
    Returns:
        dict: Market data or None if an error occurs.
    """
    market_quote_api = get_market_quote_v3_api()
    if not market_quote_api:
        logger.error("Failed to create MarketQuoteV3Api instance for get_live_market_data")
        return None

    try:
        instrument_key = f"{exchange}:{symbol}"
        # Using get_full_market_quote to get comprehensive data including LTP, change, OHLC etc.
        # The API version "3.0" should be handled by the underlying SDK method.
        # The SDK method is get_full_market_quote(symbol, api_version)
        # However, the Upstox SDK might implicitly use the correct version or require it in ApiClient config.
        # Let's assume the SDK handles the version or it's set globally.

        # The method signature for get_full_market_quote in the SDK is typically:
        # get_full_market_quote(self, symbol, api_version, **kwargs)
        # We need to ensure the api_version is correctly passed or configured.
        # For safety, let's try to pass it if the method accepts it,
        # otherwise rely on global config or SDK default.

        # The Upstox client library's MarketQuoteV3Api().get_full_market_quote takes 'symbol' and 'api_version'.
        response = market_quote_api.get_full_market_quote(
            symbol=instrument_key,
            api_version="3.0" # Explicitly pass api_version
        )

        if response and response.data:
            # The structure of response.data needs to be mapped to what the frontend expects.
            # Assuming response.data is an object with fields like last_price, change, ohlc etc.
            # Example mapping (adjust based on actual response structure from Upstox SDK):
            data = response.data
            # The V3 full market quote response is nested. Example: data.market_data.ltpc
            ltpc_data = data.get(instrument_key, {}).get('market_data', {}).get('ltpc', {})
            ohlc_data = data.get(instrument_key, {}).get('market_data', {}).get('ohlc', {})

            live_data = {
                "ltp": ltpc_data.get('ltp'),
                "change": ltpc_data.get('ch'), # Or calculate if 'ch' is not direct change value
                "percentage_change": ltpc_data.get('chp'),
                "open": ohlc_data.get('open'),
                "high": ohlc_data.get('high'),
                "low": ohlc_data.get('low'),
                "close": ohlc_data.get('close'), # Previous day close for ohlc
                "symbol": symbol,
                "instrument_key": instrument_key
                # Add other fields as needed by your frontend
            }
            return live_data
        else:
            logger.warning(f"No data received from get_full_market_quote for {instrument_key}")
            return None

    except ApiException as e:
        logger.error(f"ApiException when calling MarketQuoteV3Api->get_full_market_quote for {symbol}: {e}")
        if e.body:
            logger.error(f"Error body: {e.body}")
        return None
    except Exception as e:
        logger.error(f"Error fetching live market data for {symbol} via HTTP: {e}", exc_info=True)
        return None


def get_historical_data(symbol, interval="1day", from_date=None, to_date=None, exchange="NSE_EQ"):
    """
    Get historical OHLC data for a symbol from Upstox using V3 API

    Args:
        symbol (str): Symbol/scrip code
        interval (str): Candle interval (V3 API format: 1minute, 1day, 1week, 1month)
        from_date (str): Start date in YYYY-MM-DD format
        to_date (str): End date in YYYY-MM-DD format
        exchange (str): Exchange code, default is NSE_EQ
    """
    history_api = get_history_v3_api()
    if not history_api:
        logger.error("Failed to create HistoryV3Api instance")
        return None

    # Map the interval format from old API to new V3 API if needed
    interval_mapping = {
        "minute": "1minute",
        "day": "1day",
        "week": "1week",
        "month": "1month"
    }

    # Use the mapping if an old-style interval is provided
    if interval in interval_mapping:
        interval = interval_mapping[interval]

    try:
        # Format instrument key for Upstox API V3
        instrument_key = f"{exchange}:{symbol}"

        # Default to last 30 days if no dates provided
        if not from_date or not to_date:
            to_date = datetime.now().strftime("%Y-%m-%d")
            from_date = (datetime.now() - timedelta(days=30)).strftime("%Y-%m-%d")

        # Get historical data
        response = history_api.get_candle_data(
            symbol=instrument_key,
            interval=interval,
            from_date=from_date,
            to_date=to_date,
            api_version="3.0"
        )

        return response.data.candles if response and response.data else None
    except ApiException as e:
        logger.error(f"Exception when calling HistoryV3Api->get_candle_data: {e}")
        return None
    except Exception as e:
        logger.error(f"Error fetching historical data from Upstox for {symbol}: {e}")
        return None
def get_auth_code_from_url(redirect_url):
    """
    Extract the authorization code from the redirect URL
    For use with the redirect callback
    """
    try:
        import urllib.parse
        parsed_url = urllib.parse.urlparse(redirect_url)
        query_params = urllib.parse.parse_qs(parsed_url.query)

        if 'code' in query_params:
            return query_params['code'][0]
        return None
    except Exception as e:
        logger.error(f"Error extracting auth code from URL: {str(e)}")
        return None

def is_cache_stale(cache_file):
    """
    Check if the cache file is stale (older than 1 day)

    Args:
        cache_file (str): Path to the cache file

    Returns:
        bool: True if the file doesn't exist or is older than 1 day
    """
    try:
        if not os.path.exists(cache_file):
            logger.info(f"Cache file {cache_file} does not exist.")
            return True

        file_modified_time = datetime.fromtimestamp(os.path.getmtime(cache_file))
        current_time = datetime.now()

        # Calculate time difference in hours
        time_difference = (current_time - file_modified_time).total_seconds() / 3600

        # If cache is older than 24 hours (1 day), consider it stale
        is_stale = time_difference > 24
        if is_stale:
            logger.info(f"Cache file {cache_file} is stale, last updated {time_difference:.1f} hours ago.")

        return is_stale
    except Exception as e:
        logger.error(f"Error checking cache staleness for {cache_file}: {str(e)}")
        # If there's an error checking, consider the cache stale
        return True


def get_instruments_cache(exchange="NSE_EQ"):
    """
    Get instruments cache for the specified exchange.
    Loads from processed JSON file if available. If not, attempts to refresh it.
    Refreshes cache automatically if it's older than 1 day.

    Args:
        exchange (str): Exchange code, default is NSE_EQ (NSE Equity)

    Returns:
        list: List of instruments for the specified exchange
    """
    global _instruments_cache

    # Check if cache is already loaded in memory
    if _instruments_cache.get(exchange) is not None:
        cache_timestamp = _instruments_cache.get("last_updated")
        if cache_timestamp:
            try:
                # Check if in-memory cache is fresh (less than 1 day old)
                cache_time = datetime.fromisoformat(cache_timestamp)
                current_time = datetime.now()
                cache_age_hours = (current_time - cache_time).total_seconds() / 3600

                if cache_age_hours < 24:  # Less than 1 day old
                    return _instruments_cache[exchange]
                else:
                    logger.info(f"In-memory instrument cache is {cache_age_hours:.1f} hours old, refreshing...")
            except Exception as e:
                logger.warning(f"Error checking in-memory cache age: {e}")
                # Continue to refresh cache

    # Determine the cache file path
    cache_file_to_check = None
    if exchange == "NSE_EQ":
        cache_file_to_check = NSE_CSV_PROCESSED_PATH
    else:
        logger.warning(f"Instruments cache not implemented for exchange: {exchange}")
        return []

    # Check if file cache is stale
    cache_is_stale = is_cache_stale(cache_file_to_check)

    # If cache is stale, refresh it
    if cache_is_stale and exchange == "NSE_EQ":
        logger.info(f"Refreshing stale instrument cache for {exchange}...")
        if refresh_and_filter_nse_instruments():
            logger.info(f"Successfully refreshed instruments for {exchange}.")
            return _instruments_cache[exchange]
        else:
            logger.error(f"Failed to refresh instruments for {exchange}. Attempting to load existing cache.")

    # Try to load from file if available
    try:
        if os.path.exists(cache_file_to_check):
            with open(cache_file_to_check, 'r') as f:
                instruments = json.load(f)

            # Store in memory cache
            _instruments_cache[exchange] = instruments
            _instruments_cache["last_updated"] = datetime.now().isoformat()

            logger.info(f"Loaded {len(instruments)} instruments for {exchange} from cache file: {cache_file_to_check}")
            return instruments
        else:
            logger.warning(f"Instruments cache file not found: {cache_file_to_check}. Attempting to refresh.")
            # Attempt to refresh/create the cache file
            if exchange == "NSE_EQ":
                if refresh_and_filter_nse_instruments():
                    logger.info(f"Successfully refreshed and loaded instruments for {exchange}.")
                    # The refresh function already updates _instruments_cache
                    return _instruments_cache[exchange]
                else:
                    logger.error(f"Failed to refresh instruments for {exchange} after cache file was not found.")
                    return []
            else:
                # Should not happen if we returned earlier for non-NSE_EQ
                return []

    except json.JSONDecodeError as e:
        logger.error(f"Error decoding JSON from instruments cache file {cache_file_to_check}: {e}. Attempting to refresh.")
        if exchange == "NSE_EQ":
            if refresh_and_filter_nse_instruments():
                logger.info(f"Successfully refreshed and loaded instruments for {exchange} after JSON error.")
                return _instruments_cache[exchange]
            else:
                logger.error(f"Failed to refresh instruments for {exchange} after JSON error.")
                return []
        return [] # Should not happen
    except Exception as e:
        logger.error(f"Error loading instruments cache for {exchange} from {cache_file_to_check}: {str(e)}")
        return []

def search_instruments(query, exchange="NSE_EQ"):
    """
    Search for instruments based on a query string using Upstox OHLC V3 API

    Args:
        query (str): Search query string (symbol or name)
        exchange (str): Exchange code, default is NSE_EQ (NSE Equity)

    Returns:
        list: List of matching instruments
    """
    try:
        # Get the access token for authorization
        token = get_access_token()
        if not token:
            logger.error("Failed to get access token for instrument search")
            return []

        # Get processed instruments cache
        instruments = get_instruments_cache(exchange)
        if not instruments:
            logger.error(f"No instruments available for exchange {exchange}")
            return []

        # Perform a case-insensitive search on both symbol/tradingsymbol and name
        query = query.upper()
        results = []

        for inst in instruments:
            # Check if the query matches the symbol (using either field name) or name
            symbol = inst.get('tradingsymbol', inst.get('symbol', '')).upper()
            name = inst.get('name', '').upper()

            if query in symbol or query in name:
                # Ensure the instrument has a consistent symbol field regardless of source
                if 'symbol' not in inst and 'tradingsymbol' in inst:
                    inst['symbol'] = inst['tradingsymbol']

                results.append(inst)

                # Limit results to a reasonable number
                if len(results) >= 20:
                    break

        return results
    except Exception as e:
        logger.error(f"Error searching instruments: {str(e)}")
        return []
def search_symbols(api_client, query, exchange="NSE_EQ"):
    """
    Search for symbols using the API client

    Args:
        api_client: Configured Upstox API client
        query (str): Search query string (symbol or name)
        exchange (str): Exchange code, default is NSE_EQ (NSE Equity)

    Returns:
        list: List of matching symbols with formatted data for frontend
    """
    try:
        # First try to search using existing instruments cache
        results = search_instruments(query, exchange)

        # Format the results for frontend display
        formatted_results = []

        for inst in results:
            symbol = inst.get('symbol', '')
            name = inst.get('name', '')
            instrument_key = inst.get('instrument_key', '')
            isin = inst.get('isin', '')

            # Only include instruments with exchange NSE_EQ
            if symbol and instrument_key and inst.get('exchange') == 'NSE_EQ':
                formatted_results.append({
                    "symbol": symbol,
                    "name": name,
                    "instrument_key": instrument_key,
                    "isin": isin,
                    "exchange": "NSE_EQ"
                })

        return formatted_results
    except Exception as e:
        logger.error(f"Error in search_symbols: {str(e)}")
        return []
