{% extends 'layout.html' %}

{% block extra_head %}
<style>
    /* Ensure chart takes full height of its container */
    #chartContainer, #chart {
        height: 100%;
        width: 100%;
    }
    .watchlist-item {
        /* transition: background-color 0.2s ease-in-out; */ /* Optional: for smoother hover */
    }
    .watchlist-item:hover {
        background-color: #374151; /* gray-700 for hover, slightly lighter than panel bg */
    }
    .active-symbol {
        background-color: #3b82f6; /* blue-500 for active */
    }
    .active-symbol .symbol-name,
    .active-symbol .symbol-ltp,
    .active-symbol .symbol-description, /* Added .symbol-description here */
    .active-symbol .symbol-change,
    .active-symbol .symbol-percentage-change {
        color: #ffffff; /* White text for active symbol */
    }

    .text-positive {
        color: #22c55e; /* green-500 */
    }
    .text-negative {
        color: #ef4444; /* red-500 */
    }
    /* Custom scrollbar for webkit browsers */
    .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
    }
    .custom-scrollbar::-webkit-scrollbar-track {
        background: #1f2937; /* gray-800 */
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
        background: #4b5563; /* gray-600 */
        border-radius: 3px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: #6b7280; /* gray-500 */
    }

    /* Custom width and height for watchlist panel */
    .w-1\/4 {
        width: 25%;
        height: 80vh;
    }
</style>
{% endblock %}

{% block content %}
<div class="flex flex-col h-[80vh] bg-gray-900 text-gray-300 p-4 gap-4">
    <div class="flex-none">
        <h1 class="text-2xl font-semibold text-gray-100">Trading Dashboard</h1>
    </div>
    <div class="flex flex-grow gap-4 overflow-hidden">
        <div class="w-1/4 flex flex-col bg-gray-800 shadow-lg rounded-lg p-3">
            <h3 class="text-lg font-semibold text-gray-100 mb-2 px-1">Market Watch</h3>
            <div class="mb-3 px-1">
                <input type="text" id="symbolSearch" class="w-full p-2 border border-gray-600 bg-gray-700 text-gray-200 rounded-md focus:ring-blue-500 focus:border-blue-500 text-sm" placeholder="Search NSE Equities...">
                <div id="searchResults" class="mt-1 bg-gray-700 border border-gray-600 rounded-md shadow-lg hidden max-h-60 overflow-y-auto z-10 custom-scrollbar">
                </div>
            </div>
            <div class="flex-grow overflow-y-auto custom-scrollbar">
                <div id="watchlist" class="space-y-1">
                    <p class="text-gray-500 text-sm px-1">No symbols added yet.</p>
                </div>
            </div>
        </div>

        <!-- Right Panel: Chart -->
        <div class="w-3/4 flex flex-col bg-gray-800 shadow-lg rounded-lg p-4">
            <div class="flex-none flex justify-between items-center mb-3">
                <h3 id="chartSymbol" class="text-lg font-semibold text-gray-100">Live Chart</h3>
                <div class="flex items-center space-x-2">
                    <!-- Timeframe selector -->
                    <div class="flex items-center">
                        <label for="timeframeSelect" class="text-sm text-gray-400 mr-2">Timeframe:</label>
                        <select id="timeframeSelect" class="bg-gray-700 text-gray-200 text-sm rounded-md border border-gray-600 py-1 px-2">
                            <option value="1minute">1 Minute</option>
                            <option value="5minute">5 Minutes</option>
                            <option value="15minute">15 Minutes</option>
                            <option value="30minute">30 Minutes</option>
                            <option value="1hour">1 Hour</option>
                            <option value="1day" selected>1 Day</option>
                            <option value="1week">1 Week</option>
                            <option value="1month">1 Month</option>
                        </select>
                    </div>
                    <span id="chartStatus" class="text-sm text-gray-400"></span>
                </div>
            </div>
            <div id="chartContainer" class="flex-grow relative">
                <p id="chartPlaceholder" class="absolute inset-0 flex items-center justify-center text-gray-500">Select a symbol from the watchlist to view its chart.</p>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const socket = io({ transports: ['websocket'] }); // Ensure Socket.IO is initialized

    const symbolSearchInput = document.getElementById('symbolSearch');
    const searchResultsDiv = document.getElementById('searchResults');
    const watchlistDiv = document.getElementById('watchlist');
    const chartContainer = document.getElementById('chartContainer');
    const chartSymbolHeader = document.getElementById('chartSymbol');
    const chartStatusSpan = document.getElementById('chartStatus');
    const chartPlaceholder = document.getElementById('chartPlaceholder');
    const timeframeSelect = document.getElementById('timeframeSelect');

    let watchlist = {}; // Keyed by Upstox instrument_key
    let chartJSChart = null; // Changed from lightweightChart
    let activeInstrumentKey = null;

    // --- Load watchlist from backend on page load ---
    fetch('/api/watchlist/load')
        .then(response => response.json())
        .then(async data => {
            console.log('Loaded watchlist data:', data); // Debug loaded data
            if (data && data.success && data.watchlist && Array.isArray(data.watchlist)) {
                for (const savedItem of data.watchlist) { // savedItem can be a string or a basic object
                    const symbolToFetch = typeof savedItem === 'string' ? savedItem : (savedItem.symbol || savedItem.tradingsymbol);
                    if (!symbolToFetch) {
                        console.warn('Skipping saved watchlist item with no symbol:', savedItem);
                        continue;
                    }
                    try {
                        console.log(`Fetching details for symbol: ${symbolToFetch}`); // Debug search
                        // Fetch full instrument details to get the Upstox instrument_key
                        const searchResp = await fetch(`/search-upstox-symbols?query=${encodeURIComponent(symbolToFetch)}`);
                        const searchData = await searchResp.json();

                        console.log(`Search results for ${symbolToFetch}:`, searchData); // Debug results

                        // Check if we have success and symbols array in the response
                        if (searchData && searchData.success && searchData.symbols && searchData.symbols.length > 0) {
                            // Find exact match by symbol (case insensitive comparison)
                            const exactMatch = searchData.symbols.find(res =>
                                (res.symbol && res.symbol.toUpperCase() === symbolToFetch.toUpperCase()) ||
                                (res.tradingsymbol && res.tradingsymbol.toUpperCase() === symbolToFetch.toUpperCase())
                            );

                            // Use exact match if found, otherwise use first result
                            const fullItem = exactMatch || searchData.symbols[0];

                            if (fullItem && fullItem.instrument_key) {
                                console.log(`Adding ${symbolToFetch} to watchlist with key: ${fullItem.instrument_key}`);
                                watchlist[fullItem.instrument_key] = {
                                    symbolData: { ...fullItem, description: fullItem.name || fullItem.description || fullItem.symbol },
                                    chartSeries: null,
                                    lastTick: { last_price: fullItem.last_price || 0, change: 0, open:0, high:0, low:0, close:0, percentage_change:0, timestamp: Date.now() }
                                };
                            } else {
                                console.warn(`Could not find full details or instrument_key for saved symbol: ${symbolToFetch}`, fullItem);
                            }
                        } else {
                            console.warn(`No search results found for symbol: ${symbolToFetch}`, searchData);
                        }
                    } catch (e) {
                        console.error(`Error processing saved watchlist symbol ${symbolToFetch}:`, e);
                    }
                }

                console.log('Watchlist after loading:', Object.keys(watchlist)); // Debug final watchlist

                renderWatchlist();
                // Subscribe to all loaded watchlist items
                const keysToSubscribe = Object.keys(watchlist);
                if (keysToSubscribe.length > 0) {
                    socket.emit('subscribe_upstox_market_data', { instrument_keys: keysToSubscribe });
                    // If no active symbol yet, load the first one
                    if (!activeInstrumentKey && keysToSubscribe.length > 0) {
                        loadChartForSymbol(keysToSubscribe[0]);
                    }
                }
            } else {
                console.warn('No watchlist data found or invalid format:', data);
            }
        })
        .catch(err => {
            console.error('Failed to load watchlist:', err);
            chartStatusSpan.textContent = 'Error loading watchlist';
            chartStatusSpan.className = 'text-sm text-red-400';
        });

    // --- Save watchlist to backend whenever it changes ---
    function saveWatchlistToBackend() {
        const symbolsToSave = Object.values(watchlist).map(item => item.symbolData.symbol || item.symbolData.tradingsymbol);
        fetch('/api/watchlist/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ watchlist: symbolsToSave }) // Use 'watchlist' key for consistency
        })
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                console.warn('Failed to save watchlist:', data);
            } else {
                console.log('Watchlist saved successfully.');
            }
        })
        .catch(err => {
            console.error('Error saving watchlist:', err);
        });
    }

    // --- Socket.IO Event Handlers ---
    socket.on('connect', () => {
        console.log('Socket.IO connected for Upstox data.');
        chartStatusSpan.textContent = 'Connected';
        chartStatusSpan.className = 'text-sm text-green-400';
        // If there are items in watchlist, re-subscribe (e.g., on reconnect)
        const keysInWatchlist = Object.keys(watchlist);
        if (keysInWatchlist.length > 0) {
            socket.emit('subscribe_upstox_market_data', { instrument_keys: keysInWatchlist });
        }
    });

    socket.on('disconnect', () => {
        console.log('Socket.IO disconnected.');
        chartStatusSpan.textContent = 'Disconnected';
        chartStatusSpan.className = 'text-sm text-red-400';
    });

    socket.on('upstox_market_tick', function(tickData) {
        // console.log('Received Upstox Tick:', tickData);
        if (tickData && tickData.instrument_key && watchlist[tickData.instrument_key]) {
            const symbolInfo = watchlist[tickData.instrument_key];
            symbolInfo.lastTick = { // Ensure all expected fields are present
                last_price: tickData.last_price,
                change: tickData.change,
                percentage_change: tickData.percentage_change,
                ohlc: tickData.ohlc,
                timestamp: tickData.timestamp || Date.now(),
                last_traded_time: tickData.last_traded_time
            };

            // Update Chart.js chart if this is the active symbol
            if (chartJSChart && activeInstrumentKey === tickData.instrument_key && tickData.last_price !== undefined && tickData.last_price !== null) {
                const time = tickData.timestamp || Date.now(); // Use milliseconds for Chart.js
                const open = tickData.ohlc && tickData.ohlc.open !== undefined && tickData.ohlc.open !== null ? tickData.ohlc.open : tickData.last_price;
                const high = tickData.ohlc && tickData.ohlc.high !== undefined && tickData.ohlc.high !== null ? tickData.ohlc.high : tickData.last_price;
                const low = tickData.ohlc && tickData.ohlc.low !== undefined && tickData.ohlc.low !== null ? tickData.ohlc.low : tickData.last_price;
                const close = tickData.last_price;

                if (open === null || high === null || low === null || close === null ||
                    open === undefined || high === undefined || low === undefined || close === undefined) {
                    console.warn("Skipping Chart.js tick update due to null/undefined critical OHLC value:",
                                 { tickData, time, open, high, low, close });
                } else {
                    const newDataPoint = {
                        x: time,
                        o: parseFloat(open),
                        h: parseFloat(high),
                        l: parseFloat(low),
                        c: parseFloat(close)
                    };

                    // Check if the last point in the chart is from the same interval
                    const dataset = chartJSChart.data.datasets[0].data;
                    if (dataset.length > 0) {
                        const lastPoint = dataset[dataset.length - 1];
                        const lastTime = lastPoint.x;
                        const currentTimeframe = timeframeSelect.value;
                        let intervalMillis = getIntervalMilliseconds(currentTimeframe);

                        if (time < lastTime + intervalMillis && time >= lastTime) { // Current tick is within the last candle's interval
                            lastPoint.h = Math.max(lastPoint.h, newDataPoint.h);
                            lastPoint.l = Math.min(lastPoint.l, newDataPoint.l);
                            lastPoint.c = newDataPoint.c;
                        } else if (time >= lastTime + intervalMillis) { // New candle
                            dataset.push(newDataPoint);
                        }
                        // else: tick is older than last candle, might happen with delayed data, ignore for now or handle
                    } else {
                        dataset.push(newDataPoint);
                    }
                    chartJSChart.update('quiet'); // 'quiet' prevents animation
                }
            }
            updateWatchlistItemDisplay(tickData.instrument_key);
        }
    });

    socket.on('upstox_market_data_status', function(data) {
        console.log('Upstox Market Data Status:', data.status);
        // Only show "Connected" status, hide all subscription-related messages
        if (data.status && (
            data.status.includes('Subscribing to') ||
            data.status.includes('subscription') ||
            data.status.includes('Already subscribed') ||
            data.status.includes('WebSocket')
        )) {
            // For subscription messages, just show "Connected" if not already shown
            if (chartStatusSpan.textContent !== 'Connected') {
                chartStatusSpan.textContent = 'Connected';
                chartStatusSpan.className = 'text-sm text-green-400';
            }
            return;
        }

        // Only show non-subscription related status messages
        chartStatusSpan.textContent = data.status;
        chartStatusSpan.className = 'text-sm text-green-400';
    });

    socket.on('upstox_market_data_error', function(data) {
        console.error('Upstox Market Data Error:', data.error);
        chartStatusSpan.textContent = `Error: ${data.error}`;
        chartStatusSpan.className = 'text-sm text-red-400';
    });


    // --- Symbol Search ---
    symbolSearchInput.addEventListener('input', function() {
        const query = this.value.trim();
        if (query.length < 2) {
            searchResultsDiv.innerHTML = '';
            searchResultsDiv.classList.add('hidden');
            return;
        }
        // Use /search-upstox-symbols
        fetch(`${window.location.origin}/search-upstox-symbols?query=${encodeURIComponent(query)}`)
            .then(response => response.json())
            .then(data => {
                searchResultsDiv.innerHTML = '';

                // Check for error in the response
                if (!data.success) {
                    searchResultsDiv.innerHTML = `<div class="p-2 text-red-400">${data.error || 'Error searching for symbols'}</div>`;
                    searchResultsDiv.classList.remove('hidden');
                    return;
                }

                // Access the symbols array from the response
                const symbols = data.symbols || [];

                if (symbols.length > 0) {
                    symbols.forEach(item => { // item from Upstox search should have instrument_key
                        const resultItem = document.createElement('div');
                        resultItem.className = 'p-2 hover:bg-gray-600 cursor-pointer border-b border-gray-500 text-gray-200 text-sm';

                        // Include both symbol and name in the display
                        const symbol = item.symbol || item.tradingsymbol || '';
                        const name = item.name || item.description || '';
                        resultItem.textContent = `${symbol} - ${name}`;

                        resultItem.addEventListener('click', function() {
                            addSymbolToWatchlist(item);
                            symbolSearchInput.value = '';
                            searchResultsDiv.classList.add('hidden');
                        });
                        searchResultsDiv.appendChild(resultItem);
                    });
                } else {
                    searchResultsDiv.innerHTML = '<div class="p-2 text-gray-400 text-sm">No results found</div>';
                }
                searchResultsDiv.classList.remove('hidden');
            })
            .catch(error => {
                console.error('Error searching Upstox symbols:', error);
                searchResultsDiv.innerHTML = '<div class="p-2 text-red-400 text-sm">Error during search.</div>';
                searchResultsDiv.classList.remove('hidden');
            });
    });

    // --- Watchlist Management ---
    function addSymbolToWatchlist(item) { // item is from Upstox search result
        if (!item || !item.instrument_key) {
            console.error("Cannot add symbol: item is invalid or missing instrument_key", item);
            return;
        }
        if (watchlist[item.instrument_key]) {
            console.log("Symbol already in watchlist:", item.instrument_key);
            return; // Already in watchlist
        }

        watchlist[item.instrument_key] = {
            symbolData: { ...item, description: item.name || item.description || item.symbol }, // Ensure description
            chartSeries: null,
            lastTick: { last_price: item.last_price || 0, change: 0, open:0, high:0, low:0, close:0, percentage_change:0, timestamp: Date.now() }
        };
        renderWatchlist();
        saveWatchlistToBackend();

        socket.emit('subscribe_upstox_market_data', { instrument_keys: [item.instrument_key] });

        if (!activeInstrumentKey) {
            loadChartForSymbol(item.instrument_key);
        }
    }

    function removeSymbolFromWatchlist(instrumentKeyToRemove) { // Argument is Upstox instrument_key
        if (!watchlist[instrumentKeyToRemove]) return;

        // No direct series removal in Chart.js like Lightweight Charts, chart is destroyed and recreated
        delete watchlist[instrumentKeyToRemove];
        renderWatchlist();
        saveWatchlistToBackend();

        socket.emit('unsubscribe_upstox_market_data', { instrument_keys: [instrumentKeyToRemove] });

        if (activeInstrumentKey === instrumentKeyToRemove) {
            activeInstrumentKey = null;
            chartSymbolHeader.textContent = 'Live Chart';
            if (chartJSChart) {
                chartJSChart.destroy();
                chartJSChart = null;
            }
            // Ensure chartContainer is empty and placeholder is visible
            chartContainer.innerHTML = ''; // Clear any canvas
            const placeholder = document.createElement('p');
            placeholder.id = 'chartPlaceholder';
            placeholder.className = 'absolute inset-0 flex items-center justify-center text-gray-500';
            placeholder.textContent = 'Select a symbol from the watchlist to view its chart.';
            chartContainer.appendChild(placeholder);

            const remainingKeys = Object.keys(watchlist);
            if (remainingKeys.length > 0) {
                loadChartForSymbol(remainingKeys[0]); // Load first from remaining
            }
        }
    }

    function renderWatchlist() {
        watchlistDiv.innerHTML = '';
        const instrumentKeys = Object.keys(watchlist);
        if (instrumentKeys.length === 0) {
            watchlistDiv.innerHTML = '<p class="text-gray-500 text-sm px-1">No symbols added yet.</p>';
            return;
        }

        instrumentKeys.forEach(currentInstrumentKey => {
            const item = watchlist[currentInstrumentKey];
            if (!item || !item.symbolData) {
                console.warn("Skipping rendering for invalid watchlist item with key:", currentInstrumentKey, item);
                return;
            }
            const itemData = item.symbolData;
            const lastTick = item.lastTick || {};

            const ltp = lastTick.last_price !== undefined ? Number(lastTick.last_price).toFixed(2) : '-';
            const change = lastTick.change !== undefined ? Number(lastTick.change).toFixed(2) : '0.00';
            const percentageChange = lastTick.percentage_change !== undefined ? Number(lastTick.percentage_change).toFixed(2) : '0.00';

            let changeClass = 'text-gray-400';
            if (parseFloat(change) > 0) changeClass = 'text-positive';
            if (parseFloat(change) < 0) changeClass = 'text-negative';

            const symbolItemDiv = document.createElement('div');
            // Use instrumentKey for data-token
            symbolItemDiv.className = `watchlist-item p-2 rounded-md cursor-pointer flex flex-col ${currentInstrumentKey === activeInstrumentKey ? 'active-symbol' : 'bg-gray-800'}`;
            symbolItemDiv.setAttribute('data-token', currentInstrumentKey);
            symbolItemDiv.addEventListener('click', () => loadChartForSymbol(currentInstrumentKey));

            const topRow = document.createElement('div');
            topRow.className = 'flex justify-between items-center w-full';
            const symbolName = document.createElement('span');
            symbolName.className = 'symbol-name font-semibold text-sm text-gray-100 truncate';
            symbolName.textContent = itemData.symbol || itemData.tradingsymbol;
            topRow.appendChild(symbolName);
            const ltpSpan = document.createElement('span');
            ltpSpan.className = `symbol-ltp text-sm font-medium ${currentInstrumentKey === activeInstrumentKey ? 'text-white' : 'text-gray-200'}`;
            ltpSpan.textContent = ltp;
            topRow.appendChild(ltpSpan);
            symbolItemDiv.appendChild(topRow);

            const descriptionRow = document.createElement('div');
            descriptionRow.className = 'flex justify-between items-center w-full mt-0.5';
            const descriptionSpan = document.createElement('span');
            descriptionSpan.className = `symbol-description text-xs ${currentInstrumentKey === activeInstrumentKey ? 'text-white' : 'text-gray-400'} truncate`;
            descriptionSpan.textContent = itemData.description || itemData.name || 'N/A';
            descriptionSpan.style.maxWidth = '60%';
            descriptionRow.appendChild(descriptionSpan);
            const changeDetailsContainer = document.createElement('div');
            changeDetailsContainer.className = 'flex items-baseline';
            const changeSpan = document.createElement('span');
            changeSpan.className = `symbol-change text-xs ${changeClass}`;
            changeSpan.textContent = change;
            changeDetailsContainer.appendChild(changeSpan);
            const percentageChangeSpan = document.createElement('span');
            percentageChangeSpan.className = `symbol-percentage-change text-xs ${changeClass} ml-1`;
            percentageChangeSpan.textContent = `(${percentageChange}%)`;
            changeDetailsContainer.appendChild(percentageChangeSpan);
            descriptionRow.appendChild(changeDetailsContainer);
            symbolItemDiv.appendChild(descriptionRow);

            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = '&times;';
            removeBtn.className = 'absolute top-1 right-1 text-gray-500 hover:text-red-400 text-xs px-1';
            removeBtn.style.lineHeight = '1';
            removeBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                removeSymbolFromWatchlist(currentInstrumentKey);
            });
            symbolItemDiv.style.position = 'relative';
            symbolItemDiv.appendChild(removeBtn);
            watchlistDiv.appendChild(symbolItemDiv);
        });
    }

    function updateWatchlistItemDisplay(instrumentKeyToUpdate) { // Argument is Upstox instrument_key
        const itemDiv = watchlistDiv.querySelector(`[data-token="${instrumentKeyToUpdate}"]`);
        if (!itemDiv || !watchlist[instrumentKeyToUpdate] || !watchlist[instrumentKeyToUpdate].lastTick) return;

        const lastTick = watchlist[instrumentKeyToUpdate].lastTick;
        const ltp = lastTick.last_price !== undefined ? Number(lastTick.last_price).toFixed(2) : '-';
        const change = lastTick.change !== undefined ? Number(lastTick.change).toFixed(2) : '0.00';
        const percentageChange = lastTick.percentage_change !== undefined ? Number(lastTick.percentage_change).toFixed(2) : '0.00';

        const ltpSpan = itemDiv.querySelector('.symbol-ltp');
        if (ltpSpan) ltpSpan.textContent = ltp;

        const changeSpan = itemDiv.querySelector('.symbol-change');
        const percentageChangeSpan = itemDiv.querySelector('.symbol-percentage-change');
        let changeClass = 'text-gray-400';
        if (parseFloat(change) > 0) changeClass = 'text-positive';
        if (parseFloat(change) < 0) changeClass = 'text-negative';

        if (changeSpan) {
            changeSpan.textContent = change;
            changeSpan.className = `symbol-change text-xs ${changeClass}`;
        }
        if (percentageChangeSpan) {
            percentageChangeSpan.textContent = `(${percentageChange}%)`;
            percentageChangeSpan.className = `symbol-percentage-change text-xs ${changeClass} ml-1`;
        }
        if (instrumentKeyToUpdate === activeInstrumentKey) {
            if(ltpSpan) ltpSpan.classList.add('text-white'); // Ensure active item LTP is white
        }
    }

    function loadChartForSymbol(instrumentKeyToLoad) { // Argument is Upstox instrument_key
        if (!watchlist[instrumentKeyToLoad]) return;

        activeInstrumentKey = instrumentKeyToLoad;

        const symbolData = watchlist[instrumentKeyToLoad].symbolData;
        chartSymbolHeader.textContent = `${symbolData.symbol || symbolData.tradingsymbol} (${symbolData.description || 'N/A'})`;

        const placeholder = document.getElementById('chartPlaceholder');
        if(placeholder) placeholder.classList.add('hidden');

        if (chartJSChart) {
            chartJSChart.destroy();
            chartJSChart = null;
        }

        // Create a canvas element for Chart.js if it doesn't exist
        let canvas = chartContainer.querySelector('canvas');
        if (!canvas) {
            chartContainer.innerHTML = ''; // Clear placeholder or old chart
            canvas = document.createElement('canvas');
            chartContainer.appendChild(canvas);
        }
        const ctx = canvas.getContext('2d');

        try {
            console.log("Creating Chart.js chart...");
            chartJSChart = new Chart(ctx, {
                type: 'candlestick', // Using chartjs-chart-financial for candlestick
                data: {
                    datasets: [{
                        label: symbolData.symbol || symbolData.tradingsymbol,
                        data: [], // Will be populated by historical data
                        // borderColor: '#36A2EB', // Example color
                        // backgroundColor: 'rgba(54, 162, 235, 0.5)', // Example color
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day', // Default, will be adjusted based on data/timeframe
                                tooltipFormat: 'MMM dd, yyyy HH:mm',
                                displayFormats: {
                                    millisecond: 'HH:mm:ss.SSS',
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm',
                                    hour: 'HH:mm',
                                    day: 'MMM dd',
                                    week: 'MMM dd',
                                    month: 'MMM yyyy',
                                    quarter: 'qqq yyyy',
                                    year: 'yyyy'
                                }
                            },
                            ticks: { color: '#d1d5db' },
                            grid: { color: '#374151' }
                        },
                        y: {
                            ticks: { color: '#d1d5db' },
                            grid: { color: '#374151' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#d1d5db' } },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                        }
                    },
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    }
                }
            });
            console.log("Chart.js chart created:", chartJSChart);
        } catch (e) {
            console.error("Error creating Chart.js chart:", e);
            chartStatusSpan.textContent = 'Error creating chart';
            chartStatusSpan.className = 'text-sm text-red-400';
            if(placeholder) placeholder.classList.remove('hidden');
            return;
        }

        renderWatchlist(); // Re-render to update active styles

        const selectedTimeframe = timeframeSelect.value;
        const parts = instrumentKeyToLoad.split('|');
        const symbol = parts.length > 1 ? parts[1] : instrumentKeyToLoad;
        const exchange = parts.length > 1 ? parts[0] : 'NSE_EQ';

        console.log(`Loading historical data for Chart.js: ${symbol} (${exchange}) with timeframe ${selectedTimeframe}`);

        fetch(`/api/historical-data?symbol=${symbol}&exchange=${exchange}&interval=${selectedTimeframe}`)
            .then(response => response.json())
            .then(data => {
                if (data && data.success && data.data && Array.isArray(data.data)) {
                    console.log(`Historical data for Chart.js for ${symbol}:`, data.data.length, 'candles. First few:', data.data.slice(0,3));
                    const candles = data.data.map((candle, index) => {
                        if (!candle || !Array.isArray(candle) || candle.length < 5) {
                            console.warn(`Skipping invalid raw candle for Chart.js at index ${index} for ${symbol}:`, candle);
                            return null;
                        }
                        const time = candle[0] ? new Date(candle[0]).getTime() : null; // Milliseconds for Chart.js
                        const open = candle[1];
                        const high = candle[2];
                        const low = candle[3];
                        const close = candle[4];

                        if (time === null || open === null || high === null || low === null || close === null ||
                            open === undefined || high === undefined || low === undefined || close === undefined) {
                            console.warn(`Skipping Chart.js candle with null/undefined critical value for ${symbol} at index ${index}:`,
                                         { raw: candle, time, open, high, low, close });
                            return null;
                        }
                        return { x: time, o: parseFloat(open), h: parseFloat(high), l: parseFloat(low), c: parseFloat(close) };
                    }).filter(c => c !== null);

                    if (chartJSChart) {
                        if (candles.length > 0) {
                            chartJSChart.data.datasets[0].data = candles;
                            // Adjust time unit based on data range and timeframe
                            const timeUnit = getTimeUnitForChartJS(candles, selectedTimeframe);
                            chartJSChart.options.scales.x.time.unit = timeUnit;
                            chartJSChart.update();
                            console.log(`Set historical data for Chart.js for ${symbol}. ${candles.length} valid candles. First:`, candles[0], 'Last:', candles[candles.length-1]);
                        } else {
                            console.warn(`No valid historical Chart.js candles to set for ${symbol}`);
                            chartJSChart.data.datasets[0].data = [];
                            chartJSChart.update();
                        }
                    }
                } else {
                    console.warn(`No historical data or invalid format for Chart.js for ${symbol}:`, data);
                    if (chartJSChart) {
                        chartJSChart.data.datasets[0].data = [];
                        chartJSChart.update();
                    }
                }
            })
            .catch(err => {
                console.error('Error fetching historical data for Chart.js:', err);
            });
    }

    // --- Timeframe Change Handling ---
    timeframeSelect.addEventListener('change', function() {
        const selectedTimeframe = this.value;
        console.log('Selected timeframe for Chart.js:', selectedTimeframe);

        if (activeInstrumentKey && watchlist[activeInstrumentKey]) {
            const instrumentKeyToLoad = activeInstrumentKey;
            const parts = instrumentKeyToLoad.split('|');
            const symbol = parts.length > 1 ? parts[1] : instrumentKeyToLoad;
            const exchange = parts.length > 1 ? parts[0] : 'NSE_EQ';

            fetch(`/api/historical-data?symbol=${symbol}&exchange=${exchange}&interval=${selectedTimeframe}`)
                .then(response => response.json())
                .then(data => {
                    if (data && data.success && data.data && Array.isArray(data.data)) {
                        const candles = data.data.map((candle, index) => {
                            if (!candle || (!Array.isArray(candle) && typeof candle !== 'object') || (Array.isArray(candle) && candle.length < 5) ) {
                                console.warn(`Skipping invalid raw candle (Chart.js timeframe change) for ${symbol} at index ${index}:`, candle);
                                return null;
                            }
                            let timeVal, openVal, highVal, lowVal, closeVal;
                            if (Array.isArray(candle)) {
                                timeVal = candle[0] ? new Date(candle[0]).getTime() : null;
                                openVal = candle[1]; highVal = candle[2]; lowVal = candle[3]; closeVal = candle[4];
                            } else {
                                if (candle.time) {
                                    if (typeof candle.time === 'string' && isNaN(candle.time)) {
                                        timeVal = new Date(candle.time).getTime();
                                    } else {
                                        timeVal = String(candle.time).length > 10 ? Number(candle.time) : Number(candle.time) * 1000; // to ms
                                    }
                                } else { timeVal = null; }
                                openVal = candle.open; highVal = candle.high; lowVal = candle.low; closeVal = candle.close;
                            }
                            if (timeVal === null || openVal === null || highVal === null || lowVal === null || closeVal === null ||
                                openVal === undefined || highVal === undefined || lowVal === undefined || closeVal === undefined || isNaN(timeVal)) {
                                console.warn(`Skipping Chart.js candle (timeframe change) for ${symbol} with null/undefined/NaN value at index ${index}:`,
                                             { raw: candle, time: timeVal, open: openVal, high: highVal, low: lowVal, close: closeVal });
                                return null;
                            }
                            return { x: timeVal, o: parseFloat(openVal), h: parseFloat(highVal), l: parseFloat(lowVal), c: parseFloat(closeVal) };
                        }).filter(c => c !== null);

                        if (chartJSChart) {
                            if (candles.length > 0) {
                                chartJSChart.data.datasets[0].data = candles;
                                const timeUnit = getTimeUnitForChartJS(candles, selectedTimeframe);
                                chartJSChart.options.scales.x.time.unit = timeUnit;
                                chartJSChart.update();
                                console.log(`Set historical data (Chart.js timeframe change) for ${symbol}. ${candles.length} valid candles.`);
                            } else {
                                console.warn(`No valid historical Chart.js candles (timeframe change) for ${symbol}`);
                                chartJSChart.data.datasets[0].data = [];
                                chartJSChart.update();
                            }
                        }
                    } else {
                        console.warn(`No historical data or invalid format (Chart.js timeframe change) for ${symbol}:`, data);
                        if (chartJSChart) {
                            chartJSChart.data.datasets[0].data = [];
                            chartJSChart.update();
                        }
                    }
                })
                .catch(err => {
                    console.error('Error fetching historical data for Chart.js (timeframe change):', err);
                });
        }
    });

    // Helper function to determine appropriate time unit for Chart.js x-axis
    function getTimeUnitForChartJS(candles, timeframe) {
        if (!candles || candles.length === 0) return 'day'; // Default

        const firstTime = candles[0].x;
        const lastTime = candles[candles.length - 1].x;
        const rangeMillis = lastTime - firstTime;

        // Adjust based on timeframe first
        if (timeframe.includes('minute')) return 'minute';
        if (timeframe.includes('hour')) return 'hour';
        if (timeframe.includes('day')) return 'day';
        if (timeframe.includes('week')) return 'week';
        if (timeframe.includes('month')) return 'month';

        // Fallback based on range if timeframe is not specific enough
        const oneDay = 24 * 60 * 60 * 1000;
        if (rangeMillis <= oneDay * 2) return 'hour';       // Up to 2 days: show hours
        if (rangeMillis <= oneDay * 30 * 2) return 'day';  // Up to 2 months: show days
        if (rangeMillis <= oneDay * 365 * 2) return 'month';// Up to 2 years: show months
        return 'year'; // More than 2 years: show years
    }

    // Helper function to get interval in milliseconds
    function getIntervalMilliseconds(timeframe) {
        if (timeframe.includes('minute')) {
            const minutes = parseInt(timeframe.replace('minute', ''));
            return minutes * 60 * 1000;
        }
        if (timeframe.includes('hour')) {
            const hours = parseInt(timeframe.replace('hour', ''));
            return hours * 60 * 60 * 1000;
        }
        if (timeframe.includes('day')) return 24 * 60 * 60 * 1000;
        if (timeframe.includes('week')) return 7 * 24 * 60 * 60 * 1000;
        if (timeframe.includes('month')) return 30 * 24 * 60 * 60 * 1000; // Approximation
        return 24 * 60 * 60 * 1000; // Default to 1 day
    }

    new ResizeObserver(entries => {
        if (entries.length === 0 || entries[0].target !== chartContainer) { return; }
        if (chartJSChart) {
            // Chart.js handles responsiveness via maintainAspectRatio: false and its container size
            // chartJSChart.resize(); // Usually not needed if responsive: true and maintainAspectRatio: false
        }
    }).observe(chartContainer);

    // Initial render in case watchlist is empty or fails to load fully
    renderWatchlist();
});
</script>
{% endblock %}
